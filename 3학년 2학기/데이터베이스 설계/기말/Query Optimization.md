- **쿼리 최적화**
	- <font color="#00b0f0">주어진 쿼리를 가장 효율적으로 처리하기 위한 전략을 찾는 과정</font>
	- <font color="#00b0f0">Relation Algebra Level</font>
		- 주어진 표현식과 <font color="#00b0f0">동등한 표현식</font> 생성 후 가장 비용이 적은 계획을 선택
	- <font color="#00b0f0">Detailed Strategy</font>
		- 쿼리의 처리 위해 사용할 <font color="#00b0f0">알고리즘, 특정 인덱스</font> 선택
	- **평가 계획**
		- 각 작업에 사용되는 정확한 알고리즘과 작업의 실행이 어떻게 조정되는지 정의
	- **비용 기반 쿼리 최적화의 과정**
		1. <font color="#00b0f0">동등성 규칙</font>을 사용해 논리적으로 동등한 표현식 생성
		2. 대체 쿼리 계획을 얻기 위해 예상 비용에 따라 표현식에 주석 추가
		3. <font color="#00b0f0">추정 비용</font>에 기반하여 가장 저렴한 계획 선택
- 관계식의 변환
	- **동등한** 표현식으로 변환 하는 것
		- 이는 모든 DBMS에서 동일한 튜플 집합을 생성한다는 것을 의미
	- **등가규칙** 
		- 두 형태의 표현식이 동등한 것
		- 첫번째 형태의 표현식을 두번째 형태로 대체, Vice Versa 
		- ![[Pasted image 20231207202019.png]]
	- 등가규칙의 종류
		1. Select 분해 가능
		2. Select 교환 법칙
		3. Proj은 마지막만 필요, 나머지 생략 가능
		4. Select 
		   a. Cartesian 결합 법칙
		   b. Theta 결합 법칙
		5. Theta, Natural 교환 법칙
		6. a. Natural 결합 법칙
		     b. Theta 결합 법칙
		7. Select의 Theta대한 분배 법칙
		   a. ø<sub>0</sub> 의 모든 속성이 E1에 속하는 속성들로만 구성
		   b. ø<sub>1</sub>이 E1의 속성들로만 구성되고, ø<sub>2</sub>가 E2의 속성들로만 구성
		8. Proj의 Theta에 대한 분배 법칙
			a. ø의 모든 속성이 L1 U L2에 속할때
			b. L3 = E1 - L1 - L2, L4 = E2 - L1 - L2
		9. 합집합과 교집합 교환법칙
		10. 합집합과 교집합 결합법칙
		11. Select 합집합, 교집합, 차집합 분배법칙
		12. Proj 합집합 분배법칙
	- 최소 동등성 규칙 집합
		- 동등성 규칙 집합이 **최소**일 경우, 다른 규칙의 조합에서 어떤 규칙도 유도될 수 없음
		- 예를 들어, 7.b는 규칙1과 7.a에서 유도될 수 있기에 최소한의 동등성 규칙 집합이 아님
		- 비최소 동등성 규칙 집합을 이용하면 표현식 생성 방법 수 증가
		- 쿼리 옵티마이저는 <font color="#00b0f0">최소 동등성 규칙 집합 사용</font>
		- <u>선택 연산을 최대한 빨리 수행하여</u> <font color="#00b0f0">조인할 관계의 크기를 줄이는 것이 중요</font>
	- 조인 순서
		- 조인 작업의 순서를 잘 선택하는 것은 임시 결과의 크기를 줄이는데 중요
		- 예를 들어, (r1 r2) r3 = r1 (r2 r3) 일때 r1 r2가 작고 r2 r3이 매우 크다면, 우리는 (r1 r2) r3을 선택
		- 이렇게 <font color="#00b0f0">더 작은 임시 관계</font>를 계산하고 저장 가능
	- 동등한 표현의 열거
		- 쿼리 최적화기는 주어진 표현식과 동등한 표현식을 <font color="#00b0f0">체계적으로</font> 생성하기 위해 동등성 규칙을 사용
		- 동등한 표현 생성 위해 다음을 반복
			- 지금까지 찾은 모든 동등한 표현의 모든 하위 표현식에 모든 적용 가능한 동등성 규칙을 적용
			- 새롭게 생성된 표현식을 동등한 표현의 집합에 추가
		- 이는 매우 많은 시간 소요 - 두가지 접근 방식
			- 변환 규칙을 기반으로한 최적화된 계획 생성
			- Select, Proj, Join만 있는 쿼리에 대한 특수한 경우의 접근
	- 변환 기반 최적화 구현
		- <font color="#00b0f0">공통된 하위 표현식 공유</font>로 공간 요구 사항 감소 가능
		- <font color="#00b0f0">동적 프로그래밍</font>을 통해 시간 요구 사항 감소 가능
- 비용 추정 전략
	- 비용 추정을 위한 통계 정보
		- r이라는 관계에 있는 튜플의 수(nr)
		- r의 튜플을 포함하는 블록의 수(br)
		- r의 튜플의 크기(lr)
		- r의 블로킹 팩터(fr) - 즉, r의 튜플 중 하나의 블록에 들어갈 수 있는 튜플의 수
		- A 속성에 나타나는 r의 고유 값의 수(V(A, r)) - 즉, ∏A(r)의 크기와 동일함
		- 만약 r의 튜플이 물리적으로 파일에 함께 저장된다면
		  ![[Pasted image 20231207212624.png|100]]<font color="#00b0f0">Database-System Catalog</font>
		- 비용 추정을 위한 **근사 접근 방식**
			- 정확한 통계를 유지하려면 관계가 수정될 때 마다 통계도 업데이트 해야함
			- 대부분의 시스템은 모든 수정마다 통계를 업데이트하지 않고, 시스템 부하가 적은 시기에 통계를 업데이트
			- 따라서, 쿼리 처리 전략을 선택하기 위해 사용되는 통계는 완전히 정확하지 않을 수 있음
			- 그러나, 통계 업데이트 간격에서 업데이트 사이에 너무 많은 수정이 발생하지 않는다면, 통계는 충분히 정확할 것
	- 히스토그램
		- 실제 세계의 최적화 도구에서 비용 추정을 개선하기 위해 추가적인 통계 정보를 유지
		- 대부분의 데이터 베이스는 각 속성값의 분포를 <font color="#00b0f0">히스토그램</font>으로 저장
- 비용 추정
	- 쿼리 평가 계획의 비용은 통계 정보를 기반으로 추정됨
	- 통계 정보
		- 관계에 대한 통계적 정보
			- 튜플 수, 속성의 고유한 값 수와 같은 관계에 대한 통계적 정보를 사용해 비용 추정
		- 중간 결과에 대한 통계적 추정
			- 복잡한 표현식의 비용을 계산하기 위해 중간 결과에 대한 통계적 추정 수행
		- 통계를 사용해 알고리즘의 비용을 계산하는 비용 공식