- **쿼리 최적화**
	- <font color="#00b0f0">주어진 쿼리를 가장 효율적으로 처리하기 위한 전략을 찾는 과정</font>
	- <font color="#00b0f0">Relation Algebra Level</font>
		- 주어진 표현식과 <font color="#00b0f0">동등한 표현식</font> 생성 후 가장 비용이 적은 계획을 선택
	- <font color="#00b0f0">Detailed Strategy</font>
		- 쿼리의 처리 위해 사용할 <font color="#00b0f0">알고리즘, 특정 인덱스</font> 선택
	- **평가 계획**
		- 각 작업에 사용되는 정확한 알고리즘과 작업의 실행이 어떻게 조정되는지 정의
	- **비용 기반 쿼리 최적화의 과정**
		1. <font color="#00b0f0">동등성 규칙</font>을 사용해 논리적으로 동등한 표현식 생성
		2. 대체 쿼리 계획을 얻기 위해 예상 비용에 따라 표현식에 주석 추가
		3. <font color="#00b0f0">추정 비용</font>에 기반하여 가장 저렴한 계획 선택
- 관계식의 변환
	- **동등한** 표현식으로 변환 하는 것
		- 이는 모든 DBMS에서 동일한 튜플 집합을 생성한다는 것을 의미
	- **등가규칙** 
		- 두 형태의 표현식이 동등한 것
		- 첫번째 형태의 표현식을 두번째 형태로 대체, Vice Versa 
	- 최소 동등성 규칙 집합
		- 동등성 규칙 집합이 **최소**일 경우, 다른 규칙의 조합에서 어떤 규칙도 유도될 수 없음
		- 비최소 동등성 규칙 집합을 이용하면 표현식 생성 방법 수 증가
		- 쿼리 옵티마이저는 <font color="#00b0f0">최소 동등성 규칙 집합 사용</font>
		- <u>선택 연산을 최대한 빨리 수행하여</u> <font color="#00b0f0">조인할 관계의 크기를 줄이는 것이 중요</font>
	- 조인 순서
		- 조인 작업의 순서를 잘 선택하는 것은 임시 결과의 크기를 줄이는데 중요
		- 예를 들어, (r1 r2) r3 = r1 (r2 r3) 일때 r1 r2가 작고 r2 r3이 매우 크다면, 우리는 (r1 r2) r3을 선택
		- 이렇게 <font color="#00b0f0">더 작은 임시 관계</font>를 계산하고 저장 가능
	- 동등한 표현의 열거
		- 쿼리 최적화기는 주어진 표현식과 동등한 표현식을 <font color="#00b0f0">체계적으로</font> 생성하기 위해 동등성 규칙을 사용
		- 동등한 표현 생성 위해 다음을 반복
			- 지금까지 찾은 모든 동등한 표현의 모든 하위 표현식에 모든 적용 가능한 동등성 규칙을 적용
			- 새롭게 생성된 표현식을 동등한 표현의 집합에 추가
			- 이는 매우 많은 시간 소요 
	- 변환 기반 최적화 구현
		- <font color="#00b0f0">공통된 하위 표현식 공유</font>로 공간 요구 사항 감소 가능
		- <font color="#00b0f0">동적 프로그래밍</font>을 통해 시간 요구 사항 감소 가능
- 비용 추정 전략
	- 비용 추정을 위한 통계 정보
		- r이라는 관계에 있는 튜플의 수 **(nr)**
		- r의 튜플을 포함하는 블록의 수 **(br)**
		- r의 튜플의 크기 **(lr)**
		- r의 블로킹 팩터 **(fr)** - 즉, r의 튜플 중 하나의 블록에 들어갈 수 있는 튜플의 수
		- A 속성에 나타나는 r의 고유 값의 수 **(V(A, r))** 
		  → 즉, ∏A(r)의 크기와 동일함
		- 만약 r의 튜플이 물리적으로 파일에 함께 저장된다면
		  ![[Pasted image 20231207212624.png|100]]<font color="#00b0f0">→Database-System Catalog</font>
		  예) n<sub>student</sub>=5000, f<sub>student</sub>=50 → b<sub>student</sub>= 00
	- 비용 추정을 위한 **근사 접근 방식**
			- 정확한 통계를 유지하려면 관계가 수정될 때 마다 통계도 업데이트 해야함
			- 대부분의 시스템은 모든 수정마다 통계를 업데이트하지 않고, 시스템 부하가 적은 시기에 통계를 업데이트
			- 따라서, 쿼리 처리 전략을 선택하기 위해 사용되는 통계는 완전히 정확하지 않을 수 있음
			- 그러나, 통계 업데이트 간격에서 업데이트 사이에 너무 많은 수정이 발생하지 않는다면, 통계는 충분히 정확할 것
	- 히스토그램
		- 실제 세계의 최적화 도구에서 비용 추정을 개선하기 위해 추가적인 통계 정보를 유지
		- 대부분의 데이터 베이스는 각 속성값의 분포를 <font color="#00b0f0">히스토그램</font>으로 저장
		- 속성에 대한 히스토그램이 있다면, 보다 정확한 추정치를 얻을 수 있음
	- 선택도
		- 선택 조건의 <font color="#00b0f0">선택도</font>는 관계 r이 튜플의 조건을 만족 시킬 확률
		- r에서 만족하는 튜플의 수가 S<sub>i</sub>라면, 조건의 선택도는 S<sub>i</sub> / N<sub>i</sub> 이다
			- 논리곱![[Pasted image 20231208024524.png]]
			- 논리합![[Pasted image 20231208024543.png]]
			- 부정![[Pasted image 20231208024550.png|120]]
	- 조인 크기 추정
		- R ^ S 가 R의 키인 경우, <u>S의 튜플은 최대 한개의 R 튜플과만 결합 가능</u>
		  → R join S 의 튜플 수는 S에 있는 튜플보다 많을 수 없음
		- R ^ S 가 R을 참조하는 S의 외래키인 경우,<u> R join S의 튜플 수는 정확히 S의 튜플 수와 일치함</u> **(정말?)**
		- R ^ S 가 R 또는 S의 키가 아닌 경우, R join S 의 크기는 ![[Pasted image 20231208030350.png]]로 추정됨. 그 역이 참이라면, 추정치는 아마도![[Pasted image 20231208030421.png]]
		  히스토그램이 정확도를 높여줄 수 있음
- 평가 계획 선택
	- 평가 계획의 선택 
		- <font color="#00b0f0">평가 계획</font>은 각 작업에 대해 사용해야 하는 정확한 알고리즘과 작업의 실행을 어떻게 조정해야 하는지를 정의
			- 비용 추정을 위한 통계 및 제시된 다양한 알고리즘과 평가 방법의 비용 추정을 사용
		- <font color="#00b0f0">비용 기반 옵티마이저</font>는 주어진 쿼리와 동등한 모든 쿼리 평가 계획 공간을 탐색하고, 예쌍 비용이 가장 적은 계획을 선택
			- 복잡한 쿼리의 경우 모든 가능한 계획 공간을 탐색하는 것은 너무 많은 비용이 들 수 있으므로 대부분의 옵티마이저는 쿼리 최적화 비용을 줄이기 위한 <font color="#00b0f0">휴리스틱</font>을 포함
			- 이는 최적 계획을 찾지 못할 가능성이 있지만, 쿼리 최적화 비용을 줄일 수 있음
	- 비용 기반 조인 순서 선택
		- n개의 테이블이 있을 때 (2(n-1))!(n-1)!만큼의 다른 조인 순서가 있을 수 있음 
		  → <font color="#00b0f0">n = 3 일때 12개의 조인 순서</font>
		- <font color="#00b0f0">동적 프로그래밍</font>을 사용해 {r1,r2 … ,rn}의 모든 부분 집합에 대한 최소 비용 조인 순서를 한번만 계산하고 저장할 수 있음
	- 동적 프로그래밍 
		- 중복 계산을 없애기 위해 Memorization 활용
```C++
int memo[100] = {0};
int fibo(int n){
	if( n <= 1) return n;
	else{
		if (memo[n] > 0) return memo[n];
		memo[n] = fibo(n-1) + fibo(n-2)
		
	}
}
```
- 비용 추정
	- 쿼리 평가 계획의 비용은 통계 정보를 기반으로 추정됨
	- 통계 정보
		- 관계에 대한 통계적 정보
			- 튜플 수, 속성의 고유한 값 수와 같은 관계에 대한 통계적 정보를 사용해 비용 추정
		- 중간 결과에 대한 통계적 추정
			- 복잡한 표현식의 비용을 계산하기 위해 중간 결과에 대한 통계적 추정 수행
		- 통계를 사용해 알고리즘의 비용을 계산하는 비용 공식