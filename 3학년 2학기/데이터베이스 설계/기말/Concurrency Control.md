- **Concurrency control**
	- 트랜잭션의 기본 속성중 하나인 <font color="#00b0f0">isolation</font>에 초점
	- 여러 트랜잭션이 동시에 실행될 때, 데이터베이스에서 격리 속성이 보장되지 않을 수 있음
	- 격리를 보장하기 위해 DBMS는 동시 실행되는 트랜잭션 간 상호작용을 제어해야 함
	  → <font color="#00b0f0">concurrency control schemes</font>
	- 자주 사용되는 방법은 <font color="#00b0f0">Two phase lock protocol과 snapshot isolation</font>
- Lock based protocol
	- **lock**은 데이터 항목에 대한 동시 액세스를 제어하는 매커니즘
	- 데이터는 <font color="#00b0f0">배타적모드(X)</font>와 <font color="#00b0f0">공유모드(S)</font>로 잠길 수 있음
	- 배타적 모드는 읽기, 쓰기가 모두 가능한 상태
	- 공유모드는 데이터를 읽기만 가능한 상태
	- 트랜잭션은 concurrency contol 관리자에게 <font color="#00b0f0">락 요청</font>을 하고, 요청이 <font color="#00b0f0">승인</font>된 후에만 트랜잭션 진행
- Lock-compability matrix
	- 항목에 대해 배타적lock을 보유할 경우 다른 항목에 대해 어떤 lock도 보유 불가
	  → 둘다 read only일 경우에만 더블 락 가능, read중 write 시도시 fail
	- lock을 부여할 수 없는 경우, 요청한 트랜잭션은 다른 lock이 모두 해제될 때 까지 대기
	- 예시1![[Pasted image 20231214135417.png]]
		- read, write할때는 x락, read만 할땐 s락
	- 예시2![[Pasted image 20231214135617.png]]
		- T1이 B에서 뺀 50달러를 A에 더하기 전에 T2가 display A+B를 시도하여 총액이 300이 아닌 250으로 보여지는 inconsistency
		- 이를 방지하기 위해선 unlock을 Transaction의 끝으로 delay 시켜야 함![[Pasted image 20231214135751.png]]
- **Deadlock**
	- locking이 서로 얽혀서 순환되는 상태
	- 발생시 , 시스템은 한 트랜잭션을 롤백해야함
	  → 모든 트랜잭션은 독립적이므로, 아무거나 롤백
- Consistency vs Deadlock
	- Deadlock은 롤백하면 그만이지만, consistency problem은 dbms에서 감당할 수 없는 문제로 될 수 있음
	- <font color="#00b0f0">Deadlock이 선호되어야 함</font>
- **lock based protocol**
	- 모든 트랜잭션이 락을 요청하고 해제하는 동안 따르는 규칙
	- 가능한 스케줄 집합을 제한 →<font color="#00b0f0"> legal</font> 스케줄
	- 모든 legal 스케줄이 충돌 직렬하다면, <font color="#00b0f0">충돌 직렬화를 보장</font>
- **Starvation problem**
	- s lock  되어있는 데이터에 x lock을 요청할 시 , 다른 s lock 요청이 계속 들어와 영원히 기다리는 문제
	- s lock은 공존 가능하므로 생기는 문제
- 