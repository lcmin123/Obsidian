- **Concurrency control**
	- 트랜잭션의 기본 속성중 하나인 <font color="#00b0f0">isolation</font>에 초점
	- 여러 트랜잭션이 동시에 실행될 때, 데이터베이스에서 격리 속성이 보장되지 않을 수 있음
	- 격리를 보장하기 위해 DBMS는 동시 실행되는 트랜잭션 간 상호작용을 제어해야 함
	  → <font color="#00b0f0">concurrency control schemes</font>
	- 자주 사용되는 방법은 <font color="#00b0f0">Two phase lock protocol과 snapshot isolation</font>
- Lock based protocol
	- **lock**은 데이터 항목에 대한 동시 액세스를 제어하는 매커니즘
	- 데이터는 <font color="#00b0f0">배타적모드(X)</font>와 <font color="#00b0f0">공유모드(S)</font>로 잠길 수 있음
	- 배타적 모드는 읽기, 쓰기가 모두 가능한 상태
	- 공유모드는 데이터를 읽기만 가능한 상태
	- 트랜잭션은 concurrency contol 관리자에게 <font color="#00b0f0">락 요청</font>을 하고, 요청이 <font color="#00b0f0">승인</font>된 후에만 트랜잭션 진행
- Lock-compability matrix
	- 항목에 대해 배타적lock을 보유할 경우 다른 항목에 대해 어떤 lock도 보유 불가
	  → 둘다 read only일 경우에만 더블 락 가능, read중 write 시도시 fail
	- lock을 부여할 수 없는 경우, 요청한 트랜잭션은 다른 lock이 모두 해제될 때 까지 대기
	- 예시1![[Pasted image 20231214135417.png]]
		- read, write할때는 x락, read만 할땐 s락
	- 예시2![[Pasted image 20231214135617.png]]
		- T1이 B에서 뺀 50달러를 A에 더하기 전에 T2가 display A+B를 시도하여 총액이 300이 아닌 250으로 보여지는 inconsistency
		- 이를 방지하기 위해선 unlock을 Transaction의 끝으로 delay 시켜야 함![[Pasted image 20231214135751.png]]
- **Deadlock**
	- locking이 서로 얽혀서 순환되는 상태
	- 발생시 , 시스템은 한 트랜잭션을 롤백해야함
	  → 모든 트랜잭션은 독립적이므로, 아무거나 롤백
- Consistency vs Deadlock
	- Deadlock은 롤백하면 그만이지만, consistency problem은 dbms에서 감당할 수 없는 문제로 될 수 있음
	- <font color="#00b0f0">Deadlock이 선호되어야 함</font>
- **lock based protocol**
	- 모든 트랜잭션이 락을 요청하고 해제하는 동안 따르는 규칙
	- 가능한 스케줄 집합을 제한 →<font color="#00b0f0"> legal</font> 스케줄
	- 모든 legal 스케줄이 충돌 직렬하다면, <font color="#00b0f0">충돌 직렬화를 보장</font>
- **Starvation problem**
	- s lock  되어있는 데이터에 x lock을 요청할 시 , 다른 s lock 요청이 계속 들어와 영원히 기다리는 문제
	- s lock은 공존 가능하므로 생기는 문제
- **Two - phased locking protocol**![[Pasted image 20231214141054.png]]
	- <font color="#00b0f0">충돌 직렬 스케줄 보장</font>
	- <font color="#00b0f0">데드락을 해결할 수는 없다</font>
	- [[Cascading Rollback]] 발생 가능
	- lock, unlock 요청을 두 단계로 나눈다
	- lock point에 도달 시 작업 수행
		- <font color="#00b0f0">Growing phase</font>
			- lock을 걸 수만 있는 단계
		- <font color="#00b0f0">Shrinking phase</font>
			- lock을 풀 수만 있는 단계
	- 트랜잭션이 성장 단계에 있을때 시작, 필요에 따라 잠금 획득. 트랜잭션이 잠금을 해제하면 축소단계로 들어가며, 더이상 잠금 요청 불가
	- 잠금지점(트랜잭션이 최종 잠금을 획득한 지점)의 순서대로 트랜잭션을 직렬화 하는걸 보장
	- ![[Pasted image 20231214141326.png]]
	- lock과 unlock이 몰려있으면 투페이즈락
- <font color="#00b0f0">Strict two phase locking protocol</font>
	- [[Cascading Rollback]] 회피
	- 모든 트랜잭션 커밋까지 x락 유지 요구
	- 다른 트래잭션 커밋 전에 커밋되지 않은 데이터 read 방지
- <font color="#00b0f0">rigorous thw phase locking protocol</font>
	- 모든 트랜잭션 커밋까지 x락, s락 유지 요구
	- 트랜잭션을 커밋 순으로 직렬화 가능, 구현 용이
	- 모든 시스템은 이걸 구현해놓지만, 간단한 투페이즈락 사용
- <font color="#00b0f0">잠금 변환</font>
	- <font color="#00b0f0">업그레이드</font>
		- s락 → x락
		- 성장단계에서만 발생 가능
	- <font color="#00b0f0">다운그레이드</font>
		- x락→s락 
		- 축소단계에서만 발생 가능
	- 충돌 직렬 가능한 스케줄만 생성
	- 트랜잭션은 잠금지점에 따라 직렬화 가능
	- 배타적 잠금이 트랜잭션 끝까지 유지된다면, 스케줄은 cascadeless함
- 잠금 관리자
	- 잠금 요청에 대해 잠금 부여 메시지 전송, 데드락 롤백요청, 트랜잭션 응답까지 대기
	- 잠금 관리자는 부여된 잠금과 대기중인 요청을 기록하기 위해 잠금 테이블이라는 인메모리 데이터 구조 유지
- **snapshot isolation**
	- 트랜잭션이 실행될 때 데이터베이스의 스냅샷 제공
	- 해당 스냅샷을 동시 트랜잭션으로부터 완전히 격리된 상태에서 작업
	- 트랜잭션 T가 커밋할수있는경우, T가 데이터베이스에서 수행한 모든 업데이트를 원자적으로 수행해야함
		- 다른 트랜잭션을 위해 생성된 스냅샷은 T의 모든 업데이트를 포함하거나, 포함하지 않아야 함
- <font color="#00b0f0">First commiter win</font>
	- 첫번째 커미터가 승리
	- T와 동시에 발생한 트랜잭션이 이미 T가 쓰려는 항목에 대해 데이터베이스에 업데이트를 작성한경우, T는 avort됨
	- 이와같은 트랜잭션이 발견되지 않으면 T는 커밋되고 업데이트가 데이터베이스에 기록
	- ![[Pasted image 20231214142637.png|250]]
		- x에 write한게 T3이 