- 요약
	- 로그 기반 복구 방법
		- 모든 업데이트가 로그에 기록되어야 함
		- 로그는 안정적인 저장소에 유지되어야 함
		- 트랜잭션이 완료되었다고 간주되는 시점은 마지막 로그 레코드(커밋 로그)가 안정된 저장소에 출력된 시점
	- 체크포인팅 기술
		- 로그를 검색하고 트랜잭션을 재실행하는 오버헤드를 줄이기 위해 사용됨
	- 현대 복구 알고리즘 개념
		- 정상 작동 중에 수행된 모든 작업(마지막 완료된 체크포인트 이후)은 복구의 재실행 단계에서 재생
		- 이 상태에서 역순으로 미완료 트랜잭션의 로그 레코드를 처리하는 실행 취소 단계가 수행

- 복구 시스템
	- 데이터베이스는 원자성과 내구성 보장 위해 조치 취해야 함
	- 복구 체계는 고장 전에 존재됐던 consistent한 상태로 데이터베이스 복원 가능
- 실패 분류
	- 트랜잭션 실패
		- 논리적오류
		- 시스템오류
	- 시스템 충돌
		- 전원장애
		- HW,SW오류
		- <font color="#00b0f0">페일 스톱 가정</font>은 비휘발성 저장 장치의 내용이 시스템 충돌에 의해 손상되지 않은 것으로 가정
	- 디스크 실패
		- 헤드충돌
		- 디스크오류
- 복구 알고리즘 단계
	- 트랜잭션 처리 중에 실패로부터 복구 위해 필요한 정보가 충분히 존재하도록 하는 단계
	- 실패 후 데이터베이스 내용 복구해 원자성, 일관성, 내구성 보장하는 상태로 되돌리는 단계
- 저장소 구조
	- 휘발성 저장소
		- 시스템 충돌 견딜 수 없음
	- 비휘발성 저장소
		- 시스템 충돌 견딜 수 있음( 페일스톱가정)
	- 안정적인 저장소
		- 모든 장애 견딜수 있는 이상적인 저장소
		- 서로 다른 미디어에 복사본 유지함으로 근사화
- 데이터 액세스![[Pasted image 20231214153324.png]]
	- 물리적 블록
		- 디스크에 있는 블록
	- 시스템 버퍼 블록
		- 주기억장치에 임시로 저장되어있는 블록
	- 블록이동
		- input(B) 물리블록→메인메모리
		- output(B) 버퍼블록→디스크
			- 해당 물리적블록 대체
	- read(X)
		- 데이터X→로컬복사본Xi
	- write(X)
		- 로컬복사본Xi→버퍼블록X
	- 트랜잭션은 X에 액세스 전에 read(X)수행해야하고, write(X)는 트랜잭션 커밋 전 언제든 실행 가능
- **로그 기반의 복구 매커니즘**
	- 원자성 보장 위해 데이터베이스 자체수정이 아닌 안정된 저장소에 수정 내용을 설명하는 정보 출력
	- 커밋된 T에 의해 수행된 모든 수정 사항이 DB에 반영되지 않도록 보장
	- 중단된 트랜잭션에 의해 수행된 수정사항이 DB에 지속되지 않도록 도와줌
- 로그 기반 복구
	- 로그는 데이터베이스 업데이트 활동에 대한 정보를 유지하는 일련의 로그 레코드
		- immediate modification
			- 트랜잭션 커밋 전에도 데이터베이스 수정 가능
			- 기록 전 업데이트 로그 레코드 작성해야함
			- 업데이트 블록 저장소로 출력하는것은 커밋후에 언제든 발생 가능
			- 작성 순서와 출력 순서는 다를 수 있음
			- Undo
				- 레코드 데이터를 이전 값으로 설정
			- Redo
				- 레코드 데이터를 새 값으로 설정
		- deffered modification 
			- 트랜잭션 커밋 후에만 업데이트 수행
			- 로컬 복사본 저장하는 오버헤드
- 트랜잭션 커밋
	- 커밋되기 위해서는 커밋 로그 레코드가 안정된 저장소에 출력외어야 함
	- 이전 로그 레코드도 이미 출력 되어있어야 함
	- 트랜잭션에 의해 수행된 쓰기 작업은 커밋 전까지 버퍼에 남아있을 수 있고, 나중 출려 가능
- 동시성제어와 복구
	- 동시성 제어 방식이 T1에 의해 수정된 데이터 X를 T1이 커밋하기 전에, T2가 더 수정할 수 있도록 허용한다면, T1의 효과를 취소하기 위해 데이터 X의 이전값으로 복원하면 T2의 효과도 취소될 수 있음. → [[Cascading Rollback]] 
	- 복구 알고리즘은 일반적으로 T가 데이터항목을 수정한 경우, t가 커밋하거나 중단될 떄 까지 다른 T가 데이터항목을 수정
