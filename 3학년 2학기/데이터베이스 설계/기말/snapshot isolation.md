**snapshot isolation**
	- 트랜잭션이 실행될 때 데이터베이스의 스냅샷 제공
	- 해당 스냅샷을 동시 트랜잭션으로부터 완전히 격리된 상태에서 작업
	- 트랜잭션 T가 커밋할수있는경우, T가 데이터베이스에서 수행한 모든 업데이트를 원자적으로 수행해야함
		- 다른 트랜잭션을 위해 생성된 스냅샷은 T의 모든 업데이트를 포함하거나, 포함하지 않아야 함
	- 장점
		- 읽기는 차단되지 않음
		- 다른 트랜잭션 활동도 차단되지 않음
		- 읽기 커밋과 유사 성능 제공
		- normal anomaly 회피
		- Dirty read 없음(커밋되지 않은 데이터를 읽지않음)
		- 업데이트가 다른 트랜잭션에 의해 덮어 씌워지는 손실된 업데이트 없음
		- 반복가능하지않은 읽기 없음( 읽기를 다시 실행하면 동일한 값 볼 수 있음)
	- 단점
		- <font color="#00b0f0">Skew write</font>
			- 항상 직렬가능한 실행을 제공하지는 않음
			- 두 트랜잭션은 격리되어 있어 서로의 영향을 볼 수 없음
			- 예를 들어, A가 3이고 B가 17인 상황에서 직렬실행을 하면 A,B는 모두3이거나 모두17이어야 하지만, 스냅샷 격리에서는 두 트랜잭션이 동시에 시작하면 A,B의 값이 어떻게 될지 알수없음![[Pasted image 20231214143522.png]]
			- insert에서도 발생 가능
- <font color="#00b0f0">First commiter win</font>
	- 첫번째 커미터가 승리
	- T와 동시에 발생한 트랜잭션이 이미 T가 쓰려는 항목에 대해 데이터베이스에 업데이트를 작성한경우, T는 avort됨
	- 같은 데이터에 대해 write하지 않앗으면 둘다 커밋 가능
	- 이와같은 트랜잭션이 발견되지 않으면 T는 커밋되고 업데이트가 데이터베이스에 기록
	- ![[Pasted image 20231214142637.png|250]]
		- x에 write한게 T3이 처음이므로 , T2의 x write는 abort되고, T1→T3→T2순의 serializability 생성된다
- <font color="#00b0f0">First updater win</font>
	- Tj와 Ti가 같은 데이터에 접근하려 할때, Tj가 이미 x락 보유시 Ti는 대기
	- Tj가 중단되거나 커밋할때까지 Ti는 대기
	- Tj가 커밋하면 Ti 롤백, Tj가 중단되면 Ti 커밋
	- <font color="#00b0f0">트랜잭션 모두 실행후 중단될 것 없이, 그때 그때 롤백 가능하므로 효율성 좋다</font>
- <font color="#00b0f0">serializable snapshot isolation (SSI)</font>
	- 직렬가능을 보장
	- 스냅샷격리는 쓰기-쓰기만 추적
	- SSI는 읽기-쓰기 종속성을 따로 추적하여 사이클 발생 가능한 트랜잭션을 롤백 시킴으로 직렬성 보장