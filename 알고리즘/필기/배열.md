 - 배열의 성질
	 - O(1)에 K번째 원소를 확인 / 변경 가능
	   → 메모리상에 연속적으로 존재하므로
	- 추가적으로 소모되는 메모리의 양([[Overhead]])가 거의 없음
	- [[Cache Hit Rate]]가 높음
	- 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림
- 배열의 연산
	- O(1)
		- 임의의 위치에 있는 원소를 확인 / 변경
		- 원소를 끝에 추가
		- 마지막 원소를 제거
	- O(N)
		- 임의의 위치에 원소를 추가
		  → 원소 추가후 뒤의 원소들을 N만큼 뒤로 밀어야 하므로
		- 임의의 위치에 있는 원소를 제거
		  → 원소 제거후 뒤의 원소들을 N만큼 앞으로 당겨와야 하므로
- 기능과 구현
	- 배열 모든 원소 초기화
	  ```c++
	  int a[21];
	  int b[21][21];
	  
	  fill(a, a+21, 0);
	  ->크기 21인 배열을 0으로 초기화
	  for(int i = 0; i < 21; i++){
		  fill(b[i], b[i] + 21, 0);
	  }
	  ->크기 21*21 이차원 배열 0으로 초기화
```
	- 예제 [[Insert, Erase 구현]]
- STL Vector
	- [[Iterator]]
	- 예제 [[Vector example]]
	- 메서드 
		- O(1)
			- push_back() : 벡터 뒤에 요소를 추가
			- pop_back() : 벡터 마지막 요소 제거
		- O(N)
			- push_front() : 벡터 처음에 요소 추가
			- pop_front() : 벡터 처음 요소 제거
		- 그 외
			- size() : 저장된 요소 개수 반환
			- empty() : 벡터가 비어있는지 여부 반환
			- clear() : 벡터 모든 요소 제거
			- resize() : 벡터 크기 변경
			- reserve() : 벡터 
			  
	- =를 사용하면 deep copy 발생
	- range-based for loop
	  ```c++
	  vector<int> v1 = {1,2,3};
	  for(int e : v1)
	  -> v1 모든 원소 순회
	  for(int& e : v1)
	  ->v1 모든 원소 순회 및 레퍼런스 : 
	  for 문 내에서 v1 수정시 원본 v1도 수정
	  ```
	- 
