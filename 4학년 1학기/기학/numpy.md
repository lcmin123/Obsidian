- import numpy as np
- np.zeros(5)
	- array([0,0,0,0,0])
- np.zeros((3,4)) 
	- array([[0,0,0,0],
	  [0,0,0,0],
	  [0,0,0,0]])
- a.ndim
	- 차원 수 리턴
	- len(a.shape)와 같다
- a.size
	- 행 x 열 리턴
- a.shape
	- (3,4)
- np.ones(3,4)
	- 1로 채워진 3행 4열 배열 
- np.full((3,4),np.pi)
	- pi로 채워진 3행 4열 배열
- np.empty(2,3)
	- 초기화 되지 않은(garbage 값) 2행 3열 배열
- np.array([[1,2,3],[10,20,30]])
	- 1행 123, 2행 102030인 배열 생성
- np.arrange(1,5)
	- array([1,2,3,4])
- np.arrange(1,3,0.5)
	- array(1,1.5,2,2.5)
- np.linspace(0,1.5,4)
	- [0, 0.5, 1, 1.5]
	- 0부터 1.5포함 4등분
- np.random.rand(3,4)
	- 0~1 난수로 채워진 3행 4열 배열
- np.random.randn(3,4)
	- 평균0, 분산1 정규분포 난수로 채워진 3행 4열
- def my_function(z,y,x):
	  return x + 10 * y + 100 * z
	  
  np.fromfunction(my_function,(3,2,10))
	- 2행 10열 3개 3차원 배열 생성. 값은 my_func
- a.dtype
	- 배열 자료형 반환
	- int64, float64, complex64(복소수)
- type(np.zeros((3,4)))
	- numpy.ndarray
- a.itemsize
	- 할당 메모리 공간
- a.data
	- 할당 메모리 주소
- a.shape = (6,4)
	- 6행 4열의 배열로 reshape
	- 원본이랑 원소 개수 같아야 함
	- 별개의 메모리 공간을 사용하는 배열
- a.reshape(4,6)
	- 기존 array에 대해 다른 view를 리턴
	- **원본과 같은 메모리 공간 사용**
- a[1,2] = 999
	- a의 1행 2열 값 업데이트
- a.ravel()
	- a의 값을 갖는 1-dimensional view 생성
- **broadcasting**
	- 두 피연산자 배열의 크기가 다를 때 element wise를 위해 shape을 일치 시키려는 시도
	- rank가 다를 때
		- 차원에 1을 붙여서 차원수 맞춘다
		- np.arange(5).reshape(1,1,5)
	- r